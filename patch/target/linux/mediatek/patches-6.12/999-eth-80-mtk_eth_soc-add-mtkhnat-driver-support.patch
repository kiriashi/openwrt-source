From 096f1f857cdbc8412a4a00b834ab07d50d08dd2e Mon Sep 17 00:00:00 2001
From: "chak-kei.lam" <chak-kei.lam@mediatek.com>
Date: Thu, 5 Feb 2026 10:23:31 +0800
Subject: [PATCH] net: ethernet: mtk_eth_soc: add mtkhnat driver support

---
 drivers/net/ethernet/mediatek/Kconfig       | 24 +++++++++++++
 drivers/net/ethernet/mediatek/Makefile      |  1 +
 drivers/net/ethernet/mediatek/mtk_eth_soc.c | 39 +++++++++++++++++++++
 3 files changed, 64 insertions(+)

--- a/drivers/net/ethernet/mediatek/Kconfig
+++ b/drivers/net/ethernet/mediatek/Kconfig
@@ -40,4 +40,28 @@ config NET_MEDIATEK_STAR_EMAC
 	  This driver supports the ethernet MAC IP first used on
 	  MediaTek MT85** SoCs.
 
+config MEDIATEK_NETSYS_V2
+	tristate "MediaTek Ethernet NETSYS V2 support"
+	depends on ARCH_MEDIATEK && NET_MEDIATEK_SOC
+	help
+	  This options enable MTK Ethernet NETSYS V2 support
+
+config MEDIATEK_NETSYS_V3
+	tristate "MediaTek Ethernet NETSYS V3 support"
+	depends on ARCH_MEDIATEK && NET_MEDIATEK_SOC
+	help
+	  This options enable MTK Ethernet NETSYS V3 support for
+	  XGMAC and USXGMII.
+
+	  If you have a network system belong to this class, say Y.
+	  If unsure, say N.
+
+config NET_MEDIATEK_HNAT
+	tristate "MediaTek HW NAT support"
+	depends on NET_MEDIATEK_SOC && NF_CONNTRACK && IP_NF_NAT
+	help
+	  This driver supports the hardward Network Address Translation
+	  in the MediaTek MT7988/MT7986/MT2701/MT7622/MT7629/MT7621 chipset
+	  family.
+
 endif #NET_VENDOR_MEDIATEK
--- a/drivers/net/ethernet/mediatek/Makefile
+++ b/drivers/net/ethernet/mediatek/Makefile
@@ -11,4 +11,5 @@ mtk_eth-$(CONFIG_NET_MEDIATEK_SOC_WED) +
 endif
 obj-$(CONFIG_NET_MEDIATEK_SOC_WED) += mtk_wed_ops.o
 obj-$(CONFIG_NET_MEDIATEK_STAR_EMAC) += mtk_star_emac.o
+obj-$(CONFIG_NET_MEDIATEK_HNAT) += mtk_hnat/
 obj-$(CONFIG_NET_AIROHA) += airoha_eth.o
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -38,6 +38,10 @@
 #include "mtk_eth_soc.h"
 #include "mtk_wed.h"
 
+#if defined(CONFIG_NET_MEDIATEK_HNAT) || defined(CONFIG_NET_MEDIATEK_HNAT_MODULE)
+#include "mtk_hnat/nf_hnat_mtk.h"
+#endif
+
 static int mtk_msg_level = -1;
 module_param_named(msg_level, mtk_msg_level, int, 0);
 MODULE_PARM_DESC(msg_level, "Message level (-1=defaults,0=none,...,16=all)");
@@ -2782,6 +2786,31 @@ static int mtk_poll_rx(struct napi_struc
 
 			skb_reserve(skb, NET_SKB_PAD + NET_IP_ALIGN);
 			skb_put(skb, pktlen);
+
+#if defined(CONFIG_NET_MEDIATEK_HNAT) || defined(CONFIG_NET_MEDIATEK_HNAT_MODULE)
+			if (mtk_is_netsys_v3_or_greater(eth))
+				*(u32 *)(skb->head) = trxd.rxd5;
+			else
+				*(u32 *)(skb->head) = trxd.rxd4;
+
+			skb_hnat_alg(skb) = 0;
+			skb_hnat_filled(skb) = 0;
+			skb_hnat_set_cdrt(skb, RX_DMA_GET_CDRT(trxd.rxd7));
+			skb_hnat_magic_tag(skb) = HNAT_MAGIC_TAG;
+			skb_hnat_set_tops(skb, 0);
+			skb_hnat_set_is_decap(skb, 0);
+			skb_hnat_set_is_decrypt(skb, (skb_hnat_cdrt(skb) ? 1 : 0));
+
+			if (skb_hnat_reason(skb) == HIT_BIND_FORCE_TO_CPU) {
+				trace_printk("[%s] reason=0x%x(force to CPU) from WAN to Ext\n",
+					     __func__, skb_hnat_reason(skb));
+				skb->pkt_type = PACKET_HOST;
+			}
+
+			trace_printk("[%s] rxd:(entry=%x,sport=%x,reason=%x,alg=%x\n",
+				     __func__, skb_hnat_entry(skb), skb_hnat_sport(skb),
+				     skb_hnat_reason(skb), skb_hnat_alg(skb));
+#endif
 		}
 
 		skb->dev = netdev;
@@ -2824,8 +2853,10 @@ static int mtk_poll_rx(struct napi_struc
 				skb_dst_set_noref(skb, &eth->dsa_meta[port]->dst);
 		}
 
+#if !defined(CONFIG_NET_MEDIATEK_HNAT) && !defined(CONFIG_NET_MEDIATEK_HNAT_MODULE)
 		if (reason == MTK_PPE_CPU_REASON_HIT_UNBIND_RATE_REACHED)
 			mtk_ppe_check_skb(eth->ppe[ppe_idx], skb, hash);
+#endif
 
 		skb_record_rx_queue(skb, 0);
 		napi_gro_receive(napi, skb);
@@ -4488,6 +4519,7 @@ static int mtk_open(struct net_device *d
 		if (err)
 			return err;
 
+#if !defined(CONFIG_NET_MEDIATEK_HNAT) && !defined(CONFIG_NET_MEDIATEK_HNAT_MODULE)
 		for (i = 0; i < ARRAY_SIZE(eth->ppe); i++)
 			mtk_ppe_start(eth->ppe[i]);
 
@@ -4495,6 +4527,7 @@ static int mtk_open(struct net_device *d
 		if (err)
 			netdev_err(dev, "%s: could not start ppe roaming work: %d\n",
 				   __func__, err);
+#endif
 
 		for (i = 0; i < MTK_MAX_DEVS; i++) {
 			if (!eth->netdev[i])
@@ -4675,10 +4708,12 @@ static int mtk_stop(struct net_device *d
 
 	mtk_dma_free(eth);
 
+#if !defined(CONFIG_NET_MEDIATEK_HNAT) && !defined(CONFIG_NET_MEDIATEK_HNAT_MODULE)
 	mtk_ppe_roaming_stop(eth);
 
 	for (i = 0; i < ARRAY_SIZE(eth->ppe); i++)
 		mtk_ppe_stop(eth->ppe[i]);
+#endif
 
 	return 0;
 }
@@ -7105,6 +7140,7 @@ static int mtk_probe(struct platform_dev
 		};
 	}
 
+#if !defined(CONFIG_NET_MEDIATEK_HNAT) && !defined(CONFIG_NET_MEDIATEK_HNAT_MODULE)
 	if (eth->soc->offload_version) {
 		u8 ppe_num = eth->soc->ppe_num;
 
@@ -7129,6 +7165,7 @@ static int mtk_probe(struct platform_dev
 		if (err)
 			goto err_deinit_ppe;
 	}
+#endif
 
 	/* we run 2 devices on the same DMA ring so we need a dummy device
 	 * for NAPI to work
@@ -7184,7 +7221,9 @@ err_unreg_netdev:
 	free_netdev(eth->dummy_dev);
 err_deinit_ppe:
 	mtk_napi_del(eth);
+#if !defined(CONFIG_NET_MEDIATEK_HNAT) && !defined(CONFIG_NET_MEDIATEK_HNAT_MODULE)
 	mtk_ppe_deinit(eth);
+#endif
 	mtk_release_all_muxes(eth);
 	mtk_mdio_cleanup(eth);
 err_free_dev:
